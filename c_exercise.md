     想要拥有自由就必须时刻保持警惕
## 对于编程而言可移植性代表什么
意味着程序稍作修改或不修改就可以编译运行在其他系统
## C语言优点
可移植性、利用C可以访问硬件、操控内存中的位、效率高
## 解释源代码文件、目标代码文件和可执行文件区别
典型的C实现通过编译和链接来完成  
源代码文件指以后缀名为.c结尾的文本文件  
目标代码文件是源代码文件通过编译产生的文件，内容为机器语言  
可执行文件是由链接器将目标代码文件、系统启动代码、库文件合并而成
## 编程的七个步骤
定义程序目标->设计程序->编写代码->编译->运行程序->测试和调试程序->维护和修改程序
* 想要程序做什么首先要明确自己想做什么，思考程序需要哪些信息，进行哪些计算和控制，以及程序应该报告什么信息
* 考虑怎么用程序完成它，如何组成程序，程序的架构是什么样，如何表示数据以及用什么方法处理数据
* 编写代码
* 编译器是把源代码转换成机器语言的程序
* 运行程序
* 测试和调试程序
* 创建完程序后，发现程序有错误或想扩展程序用途就需要修改程序
  养成先规划再动手编写的好习惯，用纸笔记录程序的目标和设计框架

## 编译器的任务是什么
编译器将高级语言程序翻译成计算机所能理解的机器语言指令集程序
## 链接器任务是什么
链接器将目标代码、系统启动代码和库文件链接组成可执行文件

---
## C语言基本模块是什么
函数是C语言的基本模块
## 什么是语法错误，什么是语义错误
C语言语法错误指把有效的C符号放在错误的地方 int a=1  
语义错误指意思上的错误，即可以运行但结果不是预想的那个  int n3=n2*n2; 求n的三次方但求成了n的四次方  
## C语言的六种语句
标号语句    复合语句    表达式语句  选择语句    迭代语句    跳转语句
* 标号语句用于标识一个可以执行的程序入口，这个入口就是执行跳转和分支选择的目标，但标号本身不会改变程序的执行流程。
* 复合语句由一对花括号以及可选的，位于花括号中的一些声明和语句组成
* 表达式后面加一个分号；就构成了表达式语句
* 选择语句包含if和switch语句，用于改变程序原有的执行顺序和流程
* 迭代语句用于重复执行相同的代码，迭代语句包括do-while语句、while语句、for语句
* 跳转语句功能是让指令跳转到指定位置执行。跳转语句包括goto语句、continue语句、break语句、rerurn语句

  scanf遇到空白就停止不再读取
## 字符串常量和字符常量的区别
字符常量是基本类型char,字符串常量是派生类型(char数组),字符串常量最后有一个空字符\0

## sizeof和strlen区别
sizeof以字节为单位给出对象的大小(空字符也计算在内)，strlen给出字符串的字符长度(不包括空字符)

## 转换说明
* %e 浮点数，e计数法
* %o 无符号八进制整数
* %p 指针
* %s 字符串
* %u 无符号十进制整数
* %x 无符号十六进制整数
* %% 打印一个百分号
* %zd 表示size_t类型的值，size_t是sizeof的返回类型
* %* 抑制赋值
  pow(double,douyble) 求幂

  ## 什么是表达式
  表达式由运算符和运算对象组成

# site:*.edu.cn C语言设计 考试考题
## 基本概念
### 环境
ANSI C中存在两种不同的环境，第一种是翻译环境(源代码转换为可执行的机器指令)，第二种执行环境(用于实际执行代码)

### 目标代码
组成一个程序的多个或一个源文件通过编译分别转换为目标代码，目标代码是机器指令的初步形式，用于实现程序的语句

### 链接器
将各个目标文件由链接器捆绑在一起，形成一个单一完整的可执行程序。链接器同时会引用标准函数库中任何被该程序所用到的函数

## scanf()
scanf遇到第一个空白就不再读取输入了

fgets(ch,number,stdin)
fgets通过第2个参数限制读入的字符数来解决溢出问题，如果参数是n,将会读入n-1个字符,第3个参数是要读取的文件
### 预处理器
预处理器在源代码上执行一些文本操作

### 文件名约定
目标文件名在UNIX系统中扩展名为.o，MS-DOS系统中扩展名为.obj

### 三字母词
几个字符的序列合起来表示另一个字符

### 转义字符
\a  \b \f \n \r \t \v \ddd \xddd

### 声明
声明把特定标识符与计算机内存中的特定位置联系起来，同时也确定了存储在某位置的信息类型或数据类型
### 标识符
标识符由变量、函数、类型等组成个，它们由大小写字母、 数字、下划线组成，但不能以数字开头，标识符长度没有限制，但是标准允许编译期忽略第31个字符以后的字符

### C语言关键字
|auto|do|goto|signed|unsigned|break|double|
|--|--|--|--|--|--|--|
|if|sizeof|void|case|else|int|static|
|volatile|char|enum|long|struct|while|const|
|extern|register|switch|continue|float|return|typedef|
|default|for|short|union|

### 程序风格
良好的程序风格容易编写出易于理解和阅读的代码，大大提高程序的可读性，不良的风格和不良的文档是软件生产和维护代价高昂的两个原因

## 数据
### 基本数据类型
C语言中仅有四种基本数据类型:整型、浮点型、指针和聚合类型(数组、结构等)，所有其他类型都是从这4中基本类型的某种组合派生而来

## 整型
整型包括字符、 短整型和长整型，它们分为有符号、无符号两种版本

## 指针
指针可以有效实现高级数据结构

## 指针常量
指针常量和非指针常量在本质上不同，因为编译器负责把变量赋值给计算机内存中的位置，程序员事先无法知道某个特定的变量将存储到内存中的哪个位置

## 空语句
本身只包含一个分号，空语句不执行任何任务

## 赋值
C语言不存在赋值语句，而是表达式语句，只要在表达式后面加一个分号，就可以把表达式转换为语句

## 代码块
代码块是位于一对花括号之内可选的声明和语句列表  

{  
   /*code  
   */
}

## if语句语法
if( expression )   
{  
    statement  
}  
else  
{  
    statement   
}  
括号是if语句的一部分，而不是表达式的一部分，必须出现

## while语句语法
while( expression )  
{  
    statement  
}  

## break and continue
break用于终止循环  
continue用于终止当前循环，然后重新测试表达式的值决定是否继续执行循环  
这两条语句任何一条如果出现嵌套的循环内部，它只对最内层的循环起作用，无法使用break and continue语句影响外层循环的执行

## for语句语法
for( expression1; expression2; expression3 )  
{
    statement;  
}
statement称为循环体，expression1称为初始化部分，它只在循环开始时执行一次，expression2称为条件部分，它在循环体每次执行前都要执行一次，就像while语句中的表达式一样，expression3称为调整部分，它在循环体每次执行完毕，条件部分即将执行之前执行，三个表达式都是可选的，如果省略条件部分表示测试的值始终为真

## do while循环语句
do  
{  
statement  
}
while(expression);

## switch语句
switch( expression )  
{  
    case constant-expression:  
}  
expression结果必须为整数值
constant-expression为常量表达式 
执行过程：计算expression的值，然后执行语句列表中其case标签值与expression值匹配的语句，从这条语句执行到整个语句列表结束，而不是执行单个case标签，除非使用break语句  
如果表达式值和所有的case标签值都不匹配，所有语句会被跳过，程序不会终止，如果不想忽略不匹配的表达式值可以加一个default子句  
switch语句在执行时会贯穿所有的case标签，想要避免这种行为，必须在每个case语句后面增加break语句，default子句用于捕捉表达式值与所有case标签值均不匹配的情况，没有default子句，表达式值与所有case值不匹配时整个switch语句体将被跳过不执行  
default:  
    code
    
## goto语句
语句标签  
code_title:  
跳转  
goto code_title;

## C语言不具备布尔类型，零值解释为假，非0值解释为真

## 操作符
|操作符|名字|
|--|--|
|<<|左位移操作符|
|>>|右位移操作符|


## sizeof() 判断操作数的类型长度，以字节为单位表示，如果操作数是数组返回该数组的长度
## ()强制类型转换
## 条件操作符 expression1 ? expression2 : expression3 
## 逗号操作符用于将两个或多个表达式分割开，这些表达式自左向右逐个求值
## .和->操作符用于访问一个结构成员，如果s是结构变量，s.a访问s中名叫a的成员，如果一个指向结构的指针而不是结构本身，欲访问它的成员，就需要->操作符而不是.操作符

# 指针
## 计算机内存由位(bit)组成，每个bit可以容纳值位0或1，通常将一组组成一个单位来存储范围较大值。
## 一个字节(byte)包含8个位，可以存储无符号值0-255,或有符号值-128～127，一个字由几个字节组成取决于操作系统位数，32位一个字为4字节，64位一个字为8字节

# 进制转换
## 十进制转换二进制
        将十进制数不断除以2直到商为0 ，所有与数倒着排列就是二进制
        计算机书籍中为方便描述，D表示十进制，B表示二进制，O表示八进制，H表示十六进制但是C程序不允许这样
        十进制可以任意转换N进制，只需要除以N，直到商为0 ，所有与数倒着排列就是N进制
## 二进制转换十进制

## 八进制转换十进制

## 十六进制转换十进制

## 原码、反码、补码
        原码是对一个数二进制表示，其中最前面一位二进制(最高位)用来表示符号正或负
        整数是两个字节来表示，如果不满足前面用0来补充，0表示+ 1表示-

        正数的反码与原码相同，负数的反码是原码基础上取反，(除最高位)

        整数的补码与原码相同，负数的补码是在反码的基础上+1,即反码+1就是补码
    
## 文件标识符(盘符、路径、文件名      )


# 函数
        函数必须先定义后调用，C语言中函数是平等的，不能嵌套定义，任何函数的定义都不能出现在大括号中
        函数不能单独运行，函数可以被主函数或其他函数调用，也可以调用其他函数，但不能调用主函数
        若一个函数不写返回类型，默认为int
        函数声明一般放在函数体外，源文件的开头
        形参

## 全局变量
全局变量作用域范围从定义的地方开始，到源文件结束，在此范围任何地方，任何函数都可以使用它
## static
全局变量也分内部外部
若只想让本文件使用该全局变量，不允许别的文件访问，在定义该变量之前加static 
应该少用全局变量，占用内存时间长，使用指针代替
静态局部变量可以保留上次调用的数据  

        局部变量作用域和生存期
        static，存储类型为静态，主函数执行时分配内存，主函数结束时销毁分配内存，可在定义的大括号内使用，不可在定义的大括号外使用，不可在其他函数文件使用，若不赋初值其值为0

        全局变量的作用域和生存期
        extern，存储类型为静态，主函数执行时分配内存，主函数结束时销毁内存，本文件定义变量后可使用，本文件变量定义前声明后可使用，其他源文件声明后可用，若不赋初值其值为0
        static,存储类型为静态，主函数执行时分配内存，主函数结束时销毁内存，本文件定义变量后可使用，本文件变量定义前声明后可使用，其他源文件不可用，若不

## 编译预处理
宏定义是命令，通常行尾都不写分号
## 有参宏定义
#defin 宏名(参数) 字符序列
    例如:#define S(r) 3.14*r*r
    有参宏定义中的参数，不同于函数参数，函数参数是变量，宏定义的参数只是一个符号
    宏可以嵌套定义

    条件编译三种格式
    #if 表达式
        程序段1
    #else
        程序段2
    #endif
    作用:首先求解表达式值，若为真保留程序段1参加编译，而将程序段2废弃，若为假保留2废弃1

    #ifdef 宏名
        程序段1
    #else
        程序段2
    #endif
    作用:判断#ifdef后面的宏名是否在此之前用#define命令定义过,如果是程序段1参加编译程序段2废弃，反之相反

    #ifndef 宏名
        程序段1
    #else
    程序段2
    #endif
    作用：如果#ifndef后面的宏名是否在此之前未定义过,程序段1参加编译程序段2废弃，反之相反

## 指针
        指针的两个属性:地址和类型
        若由某种老类型派生出一种新类型，前者被称为基类型，后者被称为派生类型
        &单目运算符严格讲不是取地址运算符，而是取指针运算符
        存地址的变量，称为指针变量，和普通变量区别是他是用来存地址的，值是一个地址
        * 间接访问运算符


### 寻址
        任何变量都有值和地址两个属性，程序运行过程中，一旦给变量分配了空间，则这两个属性便确定了

### 误区解读
        int a,*p;
        p=&a;

        int a,*p=&a;
        两种作用相等，但是不能把第二种理解为(*p)=&a;数据定义中的*只是用来表示p是一个指针变量，是一个表示类型的符号，赋初值时要忽略 * ,实际执行的是p=&a;
        指针变量是存地址的，不能把整数赋给指针变量，除非先经过强制类型转换，例如p=(int *)(123);
        指针变量必须在赋值之后使用才是安全的，或者赋初值为NULL; 

## 数组

# C Array Doc
## 数组定义
### 一维数组
        类型名 数组名[常量表达式];
        数组也是一种类型，称为数组类型 
        
        ？？？
        int a[5];
        定义了一个数组类型，该数组类型是int[5],a代表整个数组

        数组名需要尊守标识符命名规则
        数组名后面[]中是一个常量表达式，其中不允许含有变量，常量表达式的值代表数组含有的元素个数，其类型应为整型或字符型、符号常量(整型)
        数组下标从0开始技术
        数组名被用作指针时，是一个指向数组守元素的指针
## 以下三种场合使用代表整个数组  
        测试整个数组的空间大小: sizeof(array_name);
        获取整个数组的指针: &array_name;
        用字符串对字符数组初始化: char ch[]="world";

## 一维数组下标变量可以用两种方法表示

        下标法: a[0]
        指针法: *a、*a(+1)
编译器最终会把下标法当成指针法来处理


## 常量
        不可能发生变化的数据称为常量
### 常量类型有
* 数值型常量
* 字符
* 字符串
* 符号常量
* 只读变量
## 变量
        变量必须先定义后使用
        变量是内存中的一段存储区域
        在内存中开辟一部分空间，把数据化成二进制存进去，这部分存储数据的空间就是变量
        变量存储空间所存取的数据可以改变，区别于常量
        变量名不能与函数名相同!
        定义变量目的:
            给该存储空间定义名字，变量名指向这块存储空间
            有了变量类型计算机可以正确分配字节，用正确方式存储

|类型表示|字节数|表示范围|
|:--:|:--:|:--:|
|char|1|0~2^8-1|
|short|2|-2^15~(2^15-1)|
|int|4|-2^31~(2^31-1)|
|long|8|-2^63~(2^63-1)
|unsigned short|2|0~(2^16-1)|
|unsigned int|4|0~(2^32-1)|
|unsigned long|8|0-(2^64-1])|
|float|4|-3.4\*10^38~3.4\*10^38|
|double|8|-1.7\*10^308~1.7\*10^308
  
        指针类型变量用来存储某种实体地址，包括变量、数组、函数等
        存储地址的变量称为指针变量
        指针变量64位操作系统内存中分配的字节数为8，32位为4
        证明:
        #include<stdio.h>
        int main(void)
        {
            int *a = NULL;
            float *b = NULL;
            double *c = NULL;
            char *d = NULL;
            printf("%d %d %d %d\n", sizeof(a), sizeof(b), sizeof(c), sizeof(d));
            return 0;
        }
        sizeof()运算符求得某种类型或某数据内存中占用多少字节(括号内写类型名或变量名或表达式)
        
## 标识符
* 标识符只能由英文字母、数字和下划线组成，但不能以数字开头
* 标识符区分大小写
* 不允许使用关键字作为标识符
* 标识符有长度限制，C89限制标识符长度不超过31个字符  
        
## 变量属性
    每个变量都有值和地址两个属性 
    变量值是变量内存中所存储的内容
    变量地址指变量在内存中所处的位置，其起始地址称为变量的地址
    每当内存中一个变量分配了空间，系统都会把变量名和它的地址、类型等信息记录，以便找到、存取
    变量获取空间后可以用 地址运算符 & 获取地址  

## 变量赋值和赋初值
    赋值号 "="  作用:计算右边表达式值然后存储到左边变量的存储空间
    区别：
        给变量分配空间的任务完成后，再给变量存放数据称为赋值
        给变量分配空间的时候向其存放数据称为赋初值
    注意:!
    变量初值相同时，不可以写成 int a=b=c=5;

# 基本数据类型
    C语言数据类型分为基本类型、构造类型，基本类型是系统固有的类型，构造类型是用户自定义的类型

## 整型常量表示
    程序中使用整型常量时可以用三种进制表示:八进制、十进制、十六进制
    例: int a=100; a=0144 a=0x64
    八进制表示整数必须用0开头
    十六进制表示整数必须用0x或0X开头
    程序中不允许使用二进制

# 实型数据
## 实型常量表示
* 3.14
* 1.25E-2
  
    第二种是指数形式，相当于科学计数法，C语言用1.25E-2这种形式代表数学中的1.25*10^-2
    C语言规定:用指数形式表示实数时，E前面必须有数字，E后面必须是整数
    实数只能用十进制表示

## 实型常量类型
* float    有效数字为7位，最后一位是近似值
* double    有效数字为15位,最后一位是近似值
    程序中表示实型常量时可在后面加F表示float型，L表示双精度型，如果不加默认为double

## 类型数据的输出
    printf("%d',a) int  
    printf("%f",a)  float 默认输出六位小数  %.3f 制定小数数位
    printf("%u",a) unsigned 
    printf("%Ld",a)  long int 
    printf("%hd",a) short int
    printf("%O",a) 八进制
    printf(%X,a) 十六进制
    printf("%E",a) 指数形式


## 字符类型数据


## 存储
    short、int、long、unsigned short、unsigned、unsigned long 以及char在计算机中存储方式相同，都是存数据的补码(用补码方式存储)，仅所占空间字节数不同
    float and double 属于实型数据类型，分为三部分存储  

* 存储符号
* 指数部分
* 小数部分


    赋值时若变量和表达式


# 选择结构
    顺序结构是由自上而下的执行，有时候一个问题的求解需要根据情况的不同选择不同的处理方式
## 关系运算符和关系表达式
### 关系运算符有6个，都是双目运算符，结合性都是自左到右
    >、<、<=、>=、!=、==
    关系运算符优先级低于算数运算符，比赋值和逗号运算符高，前4个级别相同，后2个级别相同但低于前4个
## 关系表达式
    如果一个表达式最后进行的是关系运算，则该表达式就是关系表达式
    关系表达式值是逻辑值
    关系表达式求解一次只能进行一个运算符运算，例如:c>b>a == (c>b)>a 
## 逻辑运算符和逻辑表达式
### 逻辑运算符有3个，&& || 是双目运算符， ！ 是单目运算符,结合性都是左到右
    && || ！
    在编写包含运算符&&表达式时，把最有可能为假的简单条件写在表达式的最左边，在编写包含运算符||的表达式时，把最有可能为真的简单条件写在表达式的最左边，这样可以减少程序运行时间，提交程序效率

| 运算符优先级 |
| :----------: |
|  !、++、--   |
|   *、/、%    |
|     +、-     |
| <、>、<=、>= |
|    ==、!=    |
|   &&、\|\|   |
|     ？：     |
|      =       |
|      ,       |

## if语句
### if语句的格式
    表达式可以是逻辑表达式、关系表达式、算数表达式、变量或常量，不管什么类型的表达式都取它的逻辑值

    if语句的执行过程:首先求解表达式的逻辑值，若为真执行语句1,否则执行语句2(若没有else分支什么也不做)

    if(表达式) //没有分号
        语句1
    [else
        语句2
    ]
---
    语法上if或else只能处理一条语句，这条语句称为if的子句或else的子句，如果需要处理多条语句，则必须把他们放在大括号内组成一条复合语句,if和else后面只能有一条子句，如果写了多条将导致语法或逻辑错误
    else和if的配对关系与else和哪个if对齐无关，else总是与它前面最近的、尚未配对的if配对

### if(表达式)后面加分号会导致程序的逻辑或语法错误
    if(a>b);
    {
        t=a;
        a=b;
        b=t;
    }

    上面代码相当于

    if(a>b)
        ;
    t=a;
    a=b;
    b=t;

    编程要考虑代码的简洁度、清晰度、以及程序的执行效率

## 条件运算符和条件表达式
    ?:是条件运算符，是唯一一个三目运算符，需要三个运算量参与运算
    由条件运算符组成的条件表达式，一般形式如下:
        表达式1? 表达式2：表达式3  x>y?x:y
    求值规则:若表达式逻辑值为真，则条件表达式的值(整个式子)等于表达式2的值，否则条件表达式值等于条件表达式3的值
    条件运算符级别比赋值运算符高，比关系运算符和逻辑运算符低,结合性自又至左

## switch语句
    switch语句写成的程序属于多分支选择结构
    switch语句格式如下:
    switch(表达式)
    {
        case 常量表达式1: 语句组1;
        case 常量表达式2: 语句组2;
        case 常量表达式3: 语句组3;
        case 常量表达式n: 语句组n;
        default:    语句组n+1;
    }
    表达式类型以及每个常量表达式的类型，都可以是字符型、逻辑型、整型，但不允许是float或double型，因为实数存储不精确
    每个语句组后面可以有若干条语句，不需要加大括号
    常量表达式中不能含有变量，且各个常量表达式值应互不相同
    break语句的作用是跳出它所在的swith,对于嵌套的swith,若break处于内层swith中，则只能跳出内层swith,外层swith继续执行
---
### swith语句执行过程
*   求解swith后面括号中表达式的值
*   看表达式的值与哪个常量表达式值相等，用来决定从哪开始执行语句组(不使用break终止会从该语句组执行到末尾)
*   若表达式值与所有常量表达式均不相等，则从default开始，顺序执行其后面每个语句组中的代码

# 枚举类型
可以用枚举类型声明符号名称表示整型变量，使用enum关键字可以创建一个新"类型"并指定它可具有的值(实际上enum常量是int类型，只要能使用int类型的地方就可以使用枚举类型)，枚举语法和结构语法相同，可以这样声明:
    enum enumerated_type_name {name1,name2......};
    enum spectrum {red, orange, yellow};    //该声明创建spetrum作为标记名，允许把enum spectrum作为一个类型名使用
    enum spectrum color;    //声明使color作为该类型的变量
第一个声明中花括号内的标识符枚举了spectrum变量可能有的值，这些符号常量被称为枚举符,是int类型的枚举常量

    //可以这样使用
    void f(enum color c);    color=orangel;      if(color == yellow)     for(color=red;color<yellow;color++)
声明数组时，可以用枚举常量表示数组的大小，switch语句中，可以把枚举常量作为标签

### 默认值
默认情况下枚举列表中的常量依次被赋予0、1、2、3、4、5等，在枚举声明中可以为枚举常量指定整数值
    
    enum levels{low = 100, medium = 500, high};
如果只给一个枚举常量赋值，后面的常量会被赋予后续的值

总结:
枚举类型可以当作类型使用，但实际上不好用很少用
现实中枚举类型主要用来定义符号量，而不是当成枚举类型来使用

## 什么是文件
文件通常是磁盘或固态硬盘中一段已命名的存储区  
C把文件看作是一系列连续的字节，每个字节都能被单独读取  
C提供两种文件模式：文本模式和二进制模式
### 二进制模式
程序可以访问文件的每个字节
### 文本模式
以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为C模式   

## 命令行参数
    int main(int argc, char *argv[])
argc值为命令行参数个数，默认为1(文件名)  
argv[0]是该程序的名称，依次往后是命令行参数

## exit()
exit函数关闭所有打开文件并结束程序，C标准要求用0或宏EXIT_SUCCESS表明成功程序结束，宏EXIT_FAILURE表明程序失败
exit和return的区别：  
* 在递归程序中return会把控制权交给上一级递归，而exit会结束程序,在其他函数中调用exit也能结束整个程序  

## fopen()
fopen第一个参数是待打开文件的名称，更确切的说是一个包含该文件名的字符串地址，第二个参数是一个字符串，指定待打开文件的模式  
// w模式打开一个现有文件，该文件内容就会被删除
|模式字符串|含义|
|:--:|:--:|
|r|读模式打开|
|w|写模式打开，现有文件长度截为0,如果文件不存在就创造新文件|
|a|写模式打开，现有文件末尾添加内容，如果文件不存在就创建新文件|

fopen成功打开文件后将返回文件指针，其他I/O函数可以使用这个指针指定该文件  

## getc() and putc()
getchar(fp) 从fp指定的文件中获取一个字符
putchar(ch,fpout) 字符ch放入FILE指针fpout指定的文件中

## 文件结尾
从文件中读取数据的程序在读到文件结尾时返回特殊值EOF并停止

    int ch;
    FILE *fp;
    fp = fopen("test_file", "r");

    while (ch = getc(fp) != EOF)
    {
        putchar(ch);
        ch = getc(fp);
    }

## fclose()
fclose(fp)函数关闭fp指定的文件，必要时刷新缓冲区  
如果成功关闭，fclose函数返回0,否则返回EOF  
    
    if(fclose(fp) != 0)
        printf("Error");
## 指向标准文件的指针
stdio.h头文件把三个文件指针与三个标准文件相关联,C程序会自动打开这三个标准文件
标准输入 stdin 标准输出 stdout 标准错误 stderr
这些文件指针都是指向FILE的指针，可以用作标准I/O函数的参数

# 顺序结构程序设计
## 赋值语句
    赋值表达式后面加一个分号就是赋值语句，格式如下:
        变量=表达式;
        赋值号左侧通常是变量，右侧是表达式、常量或变量
赋值时，赋值号右侧表达式的值要先计算出结果，并在运算器中把这个结果处理成相应的格式(例:整数表示为补码)然后再存给变量

## 赋值的三种数据处理方式
赋值时，赋值号右侧表达式要先计算结果，该结果存储方式和赋值号左侧变量的存储方式若相同或不同时，数据的处理方式是不同的
### 变量和表达式存储结果相同情况
    short、int、long、unsigned short、unsigned、unsigned long 以及char在计算机中存储方式相同，都是存数据的补码(用补码方式存储)，仅所占空间字节数不同

    赋值时若变量和表达式结果均属于上面类型，则两者存储方式相同，赋值时不需要转换存储方式，直接赋值二进制数据即可，但两者所占字节数未必相同，可分为一下三种处理方法  

* 若变量和表达式结果所占字节数相同，则直接把表达式结果的存储状态原样复制到内存变量
* 若变量比表达式结果短，则只截取低位部分，多余字节丢弃(溢出)
* 若变量比表达式结果长，则进行符号扩展(用符号为填充高位字节)

## 变量和表达式结果的存储方式不同
    存储方式不同的数据，赋值时不能直接赋值、截取或符号扩展，而需要更换存储方式
    例如:float、double 属于实型数据类型，但字节占用不同，这两种数据赋值也需要转换符号
分为三部分存储  
* 存储符号
* 指数部分
* 小数部分

# 缓冲区
缓存区是内存中一段存储区域，用来临时存放一些数据  
一个程序刚运行时，缓冲区总是空的

    用户输入的任何数据，都是作为一个个字符存放在缓冲区

## 函数原型
    int getchar(); return ASCII 
    使用getchar()一般会将其返回值存在一个字符变量中
    输入若个干字符再按enter键，键盘缓冲区中便会有若干字符(包括'\n')，该函数只取最前面一个，其他的仍在缓冲区
---
    int putchar(int); return ASCII
    作用：将所给的字符输出
    参数可以是字符型或整型常量、变量或表达式
---
    int printf(char *format[,arg...]);
    使用格式:
    printf("格式控制字符串",输出列表);
    作用:格式化输出，将结果输出到标准输入输出设备缓冲区
    函数的第一个参数是一个指针变量，用来存储字符串的首地址，调用该函数可以写一个字符地址或直接写一个字符串
    字符串用来规定输出格式
    若字符串中有%开头的组合，则字符串后面应该写出相应的输出项用来替换字符串中的%组合
## 可用格式字符
|格式符|含义|举例|
|:--:|:--:|:--:|
|d|
|o|用八进制输出整数|
|x|用十六进制输出整数|
|u|输出无符号整数(十进制)|"%hu,%hd",a,a|
|c|输出一个字符|"%c",c|
|s|输出字符串|"%s",a|
|f|输出单精度或双精度的实数(默认输出6位小数)|
|e|标准格式输出指数形式的浮点数|"%e",a|
|g|自动选择f或e格式(宽度小的一种)，不输出无意义的0|"%g",a|
|%|输出字符%|"%%"|

## 附加格式字符
|格式符|含义|举例|
|:--:|:--:|:--:|
|l|对整型指long，对实数型指double|"%ld,%lo,%lx,%lf",a,a,a,a|
|h|用于输出短整数|"%hd,%ho,%hx,%hu"|
|m|m是整数，规定输出最少的字符数，若不足左边用空格补足|"%3d,%9f",a,a|
|0m|同上，区别：用0不足而不是空格|"%03d,%06o"|
|.n|n是整数，对实数表示输出n位小数，对字符串表示截取n个字符|"%5.1f,%6.2s"|
|-|与m配合,输出数据靠左对齐，不足右边补空格|"%-3d"|

    不论printf()输出何种数据类型，最终输出的都是字符
---
    int scanf(char *format[,arg...])
    使用格式:
    scanf("格式控制字符串",地址列表); return input_size
    作用：执行格式化输入，从标准输入设备缓冲区读取字符序列，按指定格式进行转换后，存储于指定位置的变量中
    ！！！
    从键盘缓冲区取回的是字符，由scanf()转换为相应的数据后再存储
    说明：scanf与printf格式类似，只是不能使用-、0和.n区别:括号内字符串后面的是地址列表，用来指定数据的存储位置
    scanf()格式化字符串中使用*说明：放在%之后，其他字符之前，表示虚读一个数据，但不往内存中送，丢弃;例如:
        scanf("%d%*d%d",&a,&b);
        输入两个参数时，需要用分隔符分开(空格、TAB键('\t')、换行符('\n'))
        若格式控制字符串规定了数据的宽度，输入时可以不要分隔符，例如：
        scanf("%2d,%3d",&a,&b);
        读取数据时，遇到非法字符会认为该数据结束、
        字符型数据前后都不需要分隔符，应该分隔符也是字符，而且字符都是单个，不需要分隔
        若格式控制字符串中除了以%开头的组合之外还有其他字符，则输入时必须原样输入
        
## 声明结构的形式
结构类型是虚的，结构变量才是实体
    //声明了point结构类型
    struct point{
        int x;
        int y;
    }
    //定义变量
    struct point p1,p2;

    //无名结构类型
    struct{
        int x;
        int y;
    }p1,p2;

    //声明point结构类型并定义变量
    struct point{
        int x;
        int y;
    }p1,p2;
## 初始化值
struct point a={1,3};
struct point b={.x=7};


## 访问结构成员
结构用.结构成员运算符和名字访问其成员
    a.x; b.y;
结构的指定初始化器使用.运算符和成员名表示特定元素
struct point {.x=2};
C允许把结构赋值给另一个结构
##  结构指针
结构变量名字并不是结构变量地址，必须用&运算符

    struct date *pDate=&point;

## 结构作为函数参数
    int swap(struct point a)
*   整个结构可以作为参数的值传入函数
*   这个时候函数新建了一个结构变量，并复制调用者的结构的值
*   也可以返回一个结构
  
    -> 表示指针所指向结构成员

## 结构数组
    struct date dates[100];
    struct date dates[]={
        {1,2,3},{2,3,4}
    };


## 嵌套结构


## typedef 
    typedef struct ADate
    {
        int month;
        int day;
        int year;
    }Date;
    Date d={9,1,2012};
typedef 声明一个已经数据类型的新名字(别名)，Date是struct ADate的新名字


## 练习题
1、给出今天(today)的日期，计算明天(tomorrow)的日期 
    要求:使用结构体

2、创建一个结构体，用函数改变该结构体的值

被占用的物理内存C语言中称为对象
int one=1;
该声明创建了一个名为one的标识符，这种情况下标识符可以用来指定特定对象的内容，标识符是C程序指定硬件内存中的对象的方式

## 作用域
一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域、文件作用域

## 链接
C变量有三种链接属性：外部链接、内部链接、无链接，具有块作用域、函数作用域、函数原型作用域的变量都是无链接变量，意味着这些变量属于定义他们的块、函数或函数原型，具有文件作用域的变量可以是外部链接或内部链接
外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用


## 数组变量是特殊的指针
    数组变量本身表达地址，所以int a[10]; int *p=a; //无需&取地址
    但是数组的单元表达的变量，需要用&取地址 a==&a[0]
    []运算符也可以对数组做，也可以对指针做 p=[0]==a[0];
    *运算符可以对指针做，也可以对数组做
    数组变量不能相互做赋值  

    如果const标志在*前面表示所指的东西不能被修改
    如果const标志在*后面表示指针不能被修改

    const int *p1=&i;
    *p=26    错误
    p=&j;    正确
    int const *p2=&i;
    int *const p3=&i;


# 计算机基础知识练习题
## 内存和外存各有什么特点?有什么共同特性?

## 什么叫内存地址?

## 八进制、十进制、十六进制、二进制的转换

## 求补码、反码，分别用八进制、二进制、十六进制表示

## 设整数用两个字节存储，所能存储的最大数是多少，最小数是多数

## 计算机语言怎么分类的？各有什么优缺点

## C语言从源程序到运行，中间经历了怎样的处理过程

## 高级语言的解释方式和编译方式，哪一种效率最高

## 为什么汇编语言和高级语言的执行效率比机器语言低

## 什么是算法？为什么说算法是程序的灵魂？

## 算法有什么特性？

## 用传统流程图和N-S流程图表示算法
### 将变量a,b中的值互换
### 找出6个整数的最大数
### 找出两个整数的最大公约数
## 判断一个整数是不是素数

# D 表示十进制 B表示二进制 O 表示八进制 H 表示十六进制
## 二进制特点
        只有两个数字: 0 和 1
        逢二进一: 1+1=10
        
## 十进制转换二进制
        将十进制不断除以2直到商为0为止，每次除以2时记录余数，最后将所有余数倒着排列就是所求的二进制数
例如: 100D=1100100B

## 二进制转换十进制
        对于一个N进制的整数，从最右边一位开始向左，每位数字的权重依次是N^0，N^1,N^2,N^3......
       
        要将二进制转换为十进制只需要每一位上的数字乘以其权重，然后各部分相加即可
例如: 0*2^0 + 1*2^1 + 0*2^2 = 2 

## 二进制转换八进制
        对二进制进行分组，从右至左每三位分为一位，然后计算每一组的数据

例如: 11111010B=(11 111 010)=372O 1100100B=144O


## 八进制转换二进制
        将每一位八进制数都化为3个二进制数，按顺序排列起来，将不必要的0去掉(最高位的0没有意义)
        例如:372O化为三个二进制数=011 111 010 所以372O=11111010B

## 二进制转换十六进制
        十六进制数范围0-9 A-F
        对二进制数重新分组,从右至左每4位分为一组，然后计算出每一组的数据
        例如:1100110101111B=(1 1001 1010 1111)=19AFH

## 十六进制转换二进制
        将每一位十六进制数都化为4个二进制数，按顺序排列起来，将不必要的0去掉(最高位的0没有意义)
        例如:2C5H=1011000101B

## 原码、反码、补码
        原码是对一个数二进制表示，其中最前面一位二进制(最高位)用来表示符号正或负
        整数是两个字节来表示，如果不满足前面用0来补充，0表示+ 1表示-

        正数的反码与原码相同，负数的反码是原码基础上取反，(除最高位)

        整数的补码与原码相同，负数的补码是在反码的基础上+1,即反码+1就是补码

        
